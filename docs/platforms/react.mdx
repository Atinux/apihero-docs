---
sidebar_position: 1
hide_title: true
sidebar_label: "React"
---

# React

This guide goes into detail on how to use API Hero in your React project. If you'd like to quickly get started, please check out our [React Quick Start](/react-quick-start).

## Installation

If you've used the CLI to add API Hero to your project, it will have installed `@apihero/react` for you. You can always install it manually like so:

```bash npm2yarn
npm install @apihero/react@latest
```

## Usage

If you've ever used [TanStack Query](https://tanstack.com/query/v4) before, you will feel right at home with our `react` package. That's because it's powered by TanStack Query!

If you haven't used TanStack Query before, don't worry! This guide doesn't assume any prior knowledge and walks through everything you should need to know.

### Setup

Before you can start making any requests to API Hero, you first need to add the `ApiHeroProvider` component to your component tree, ideally at the very top. Here are some examples:

<Tabs groupId="react-platform">
<TabItem value="next" label="Next.js">

```tsx title="pages/_app.tsx"
// other imports here
import { ApiHeroProvider } from "@apihero/react";

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <ApiHeroProvider projectKey="<projectKey>">
      <Component {...pageProps} />
    </ApiHeroProvider>
  );
}

export default MyApp;
```

</TabItem>

<TabItem value="cra" label="Create React App">

```tsx title="src/App.tsx"
// other imports here
import { ApiHeroProvider } from "@apihero/react";

const root = ReactDOM.createRoot(
  document.getElementById("root") as HTMLElement
);
root.render(
  <React.StrictMode>
    <ApiHeroProvider projectKey="<projectKey>">
      <App />
    </ApiHeroProvider>
  </React.StrictMode>
);
```

</TabItem>

<TabItem value="gatsby" label="Gatsby">

```tsx title="src/pages/index.tsx"
// other imports here
import { ApiHeroProvider } from "@apihero/react";

const IndexPage = () => {
  return <>...</>;
};

export default () => (
  <ApiHeroProvider projectKey="<projectKey>">
    <IndexPage />
  </ApiHeroProvider>
);
```

</TabItem>

<TabItem value="vite" label="Vite">

```tsx title="src/main.tsx"
// other imports here
import { ApiHeroProvider } from "@apihero/react";

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <ApiHeroProvider projectKey="<projectKey>">
      <App />
    </ApiHeroProvider>
  </React.StrictMode>
);
```

</TabItem>
</Tabs>

You'll need to replace `<project key>` with your actual projectKey, which you can find from your project dashboard on `app.apihero.run`.

:::tip

Although it may seem unsafe, it is okay to put the `projectKey` in your code. The `projectKey` is a unique identifier for your project, and is used to authenticate with the API Hero API. It is not a secret, think of it more as a username.

:::

### Fetching data

There are two steps to fetching data from an API: creating a query hook using `createQuery` and using the query hook.

Before getting too far ahead of ourselves, let's quickly take a step back and discuss what exactly is a **query** and a **hook**. A **query** is request to fetch data from an API, usually a `GET` request but sometimes these can be `POST`. Endpoints like GitHub's [`getRepo`](https://docs.github.com/en/rest/repos/repos#get-a-repository) is a performed using a query.

:::note

As opposed to queries, a **mutation** is when we want to write data back to an API. We'll cover these in more detail later in this guide.

:::

A **hook** is a React hook, used primarily since React 16.8+ to use state and other React features, like `useState` and `useEffect`. There's lots of documentation on hooks out there, so we won't cover them exhaustively here. We suggest reading the [beta docs here](https://beta.reactjs.org/learn#using-hooks) as a good start.

So putting that all together we get the **query hook**, which is a React hook that performs a query to fetch some data from an API.

To create a **query hook**, import the `createQuery` function from `@apihero/react` and the endpoint you'd like to use, and then call `createQuery` and pass in the endpoint, like this:

```ts title="src/Repo.tsx"
import { repos } from "@apihero/github";
import { createQuery } from "@apihero/react";

const useGetRepository = createQuery(repos.getRepo);
```

Notice how we named the variable with the `use` prefix, which signals to the user of this function that `useGetRepository` is a React hook and should be used as such, inside a React component, like this example:

```ts title="src/Repo.tsx"
export function Repo({ owner, repo }: { owner: string; repo: string }) {
  const result = useGetRepository({
    owner,
    repo,
  });

  return (
    <>
      {result.status === "loading" ? (
        <Spinner />
      ) : result.status === "error" ? (
        <p>Oops, repo {result.error.message.toLowerCase()}</p>
      ) : (
        <h2>{result.data.stargazers_count} stars</h2>
      )}
    </>
  );
}
```

The `result` object contains information about the query and can be in one of three states: `loading`, `error`, or `success`.

- `loading` the query is fetching the data from the endpoint, but has not yet returned.
- `error` the query encountered an error. In this case the `result.error` property holds information about what went wrong.
- `success` the query succeeded, and the data returned from the endpoint is available at `result.data`.

Using some TypeScript magic, with the query is a `success`, then `result.data` is the appropriate type for the `getRepo` endpoint response body, which provides nice autocomplete and prevents errors when access the response:

![stargazers_count](/img/react/stargazers_count.png)

### Customizing the Query Hook behaviour

By default, query hooks created through `createQuery` have retrying turned off and will not refetch on window focus. You can customize this behaviour (and any other `useQuery` option) by passing a second parameter to `createQuery`, like so:

```ts
const useGetRepository = createQuery(repos.getRepo, {
  retry: 6,
  refetchOnWindowFocus: true,
});
```

You can also pass this options parameter when using the query hook, like so:

```ts
const result = useGetRepository(
  {
    owner,
    repo,
  },
  { retry: 6 }
);
```

This will allow you to do things like [Dependent Queries](https://tanstack.com/query/v4/docs/guides/dependent-queries) by passing the `enabled` option:

```ts
const repoResult = useGetRepository(
  {
    owner,
    repo,
  },
  { retry: 6 }
);

const userResult = useGetUserByUsername(
  {
    username: repoResult.data?.username ?? "",
  },
  {
    enabled: !!repoResult.data?.username,
  }
);
```

The above will cause the `useGetUserByUsername` endpoint to be fetched only after the result comes back from `useGetRepository`. For more about dependent queries, please consult the TanStack Query [docs](https://tanstack.com/query/v4/docs/guides/dependent-queries).

### Writing data

When you want to write data back to an API, you'd use a **mutation hook**, created through our `createMutation` function. This function works very similarly to `createQuery`, with a few key differences.

```ts title="src/NewRepo.tsx"
import { repos } from "@apihero/github";
import { createMutation } from "@apihero/react";

const useCreateRepo = createMutation(repos.createForAuthenticatedUser);
```

As you can see, we've created a **mutation hook** called `useCreateRepo`. Mutation hooks are backed by TanStack Query's [useMutation](https://tanstack.com/query/v4/docs/guides/mutations), which means you are given a `mutate` function to call on the result of the hook itself. It's a little hard to describe so here is an example:

```ts title="src/NewRepo.tsx"
function NewRepo() {
  const newRepo = useCreateRepo();

  if (newRepo.status === "loading") {
    return <div>Creating repo...</div>;
  }

  if (newRepo.status === "error") {
    return <div>An error occurred: {newRepo.error.message}</div>;
  }

  if (newRepo.status === "success") {
    <div>Repo created {newRepo.data.id}</div>;
  }

  return (
    <button onClick={() => newRepo.mutate({ title: "@apihero/react" })}>
      Create Repo
    </button>
  );
}
```

You can pass mutation options to the **mutation hook**, just like you can with **query hooks**:

```ts
function NewRepo() {
  const newRepo = useCreateRepo({ onSuccess: (data) => console.log(data) });

  // ...
}
```

To learn more about mutations, please visit the fantastic TanStack Query [docs](https://tanstack.com/query/v4/docs/guides/mutations).

### Invalidating queries

We will automatically locally cache the results of API responses when using a **query hook**, only refetching results when the query becomes stale. There are times when you will want to specifically invalidate a query (thus manually making it stale), which will trigger a refetch. For example, if you are doing both a query and a mutation, after the mutation has succeeded, you can invalidate the query to refetch the updated data. We expose the `invalidateQuery` function to do just this, allowing you to pass in the endpoint you'd like to invalidate. Here's an example:

```ts title="src/NewRepo.tsx"
import { repos } from "@apihero/github";
import { createMutation, createQuery, invalidateQuery } from "@apihero/react";

const useGetRepo = createQuery(repos.getRepo);
const useUpdateRepo = createMutation(repos.update);

function UpdateRepo({ owner, repo }: { owner: string; repo: string }) {
  const repoQuery = useGetRepo({ owner, repo });
  const updateRepo = useUpdateRepo({
    onSuccess: () => {
      invalidateQuery(repoQuery.endpoint, { owner, repo });
    },
  });

  return (
    <div>
      <h1>Update {repoQuery.data?.name}</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          const formData = new FormData(e.target);
          updateRepo.mutate({ name: formData.get("name") });
        }}
      >
        <input type="text" name="name" defaultValue={repoQuery.data?.name} />
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}
```

There is a lot going on above, but let's zoom in on the `useUpdateRepo` usage:

```ts title="src/NewRepo.tsx"
function UpdateRepo({ owner, repo }: { owner: string; repo: string }) {
  const repoQuery = useGetRepo({ owner, repo });
  const updateRepo = useUpdateRepo({
    onSuccess: () => {
      invalidateQuery(repoQuery.endpoint, { owner, repo });
    },
  });
  // ...
}
```

We pass an `onSuccess` callback to the `useUpdateRepo` hook, so that when the `updateRepo` mutation succeeds, we can invalidate the `repoQuery`, by calling `invalidateQuery`, passing in both the endpoint (returned from the **query hook**), and the parameters that we passed to that **query hook** above.

This will cause the `useGetRepo` hook to refetch the API, and then React will takeover and rerender the rest of the component, filling in our new repo `name`.

The `invalidateQuery` function takes two additional properties, `filters` and `options`. You can read more above these options in the TanStack Query docs [here](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientinvalidatequeries).
